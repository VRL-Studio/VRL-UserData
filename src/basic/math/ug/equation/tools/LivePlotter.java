
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package basic.math.ug.equation.tools;

import basic.math.helpers.CustomAppearance;
import basic.math.ug.path.UGVariables;
import eu.mihosoft.vrl.animation.Animation;
import eu.mihosoft.vrl.animation.FrameListener;
import eu.mihosoft.vrl.annotation.ComponentInfo;
import eu.mihosoft.vrl.annotation.MethodInfo;
import eu.mihosoft.vrl.annotation.ObjectInfo;
import eu.mihosoft.vrl.reflection.DefaultMethodRepresentation;
import eu.mihosoft.vrl.reflection.DefaultObjectRepresentation;
import eu.mihosoft.vrl.reflection.VisualCanvas;
import eu.mihosoft.vrl.reflection.VisualObject;
import eu.mihosoft.vrl.v3d.AppearanceArray;
import eu.mihosoft.vrl.v3d.Shape3DArray;
import eu.mihosoft.vrl.v3d.TxT2Geometry;
import eu.mihosoft.vrl.visual.Canvas;
import eu.mihosoft.vrl.visual.Task;
import java.io.File;
import java.io.Serializable;
import javax.media.j3d.Appearance;
import javax.media.j3d.Geometry;
import javax.media.j3d.Shape3D;


/**<p>
 * LivePlotter shows during calculation the evolution of the solution.
 * </p>
 * LivePlotter loads the latest plot file which was generated by the last timestep of
 * the calculation and shows actuall calculated geometry.
 *
 * @author night
 */
@ObjectInfo(name="LivePlotter")
@ComponentInfo(name = "LivePlotter", category = "BasicMath")
public class LivePlotter implements Serializable {

    private static final long serialVersionUID = 1;
    private transient VisualCanvas mainCanvas;
    private transient AppearanceArray appearances;
    private transient DefaultMethodRepresentation thisMethod;
    private transient Animation runningAnimation = null;

    /**
     * Sets the main canvas object.
     * @param mainCanvas the main canvas object
     */
    @MethodInfo(noGUI = true, callOptions = "assign-to-canvas")
    public void setMainCanvas(Canvas mainCanvas) {
        this.mainCanvas = (VisualCanvas) mainCanvas;
    }

    /**
     * Checks which is the latest file which was generated and returns a string 
     * with the path and the name of the file.
     * @return string with completted path to latest file including the name of the file
     */
    private String checkForNextFile() {

        int index = 0;
        int fileCount = 0;

        boolean fileExists = true;

        while (fileExists) {
            fileCount = index - 1;
            fileExists = new File(generateFileName(index)).exists();
            index++;
        }

        return generateFileName(fileCount);
    }

    /**
     * Generates a string which contains path and name of a plot file
     * @param index of the file
     * @return string with path and name of plot file in it
     */
    private String generateFileName(int index) {
        return UGVariables.APPL2D + "/plot" +
                index + ".txt";
    }

    /**
     * Sets the appearances that should be used to draw the geometry.
     * 
     * @param array with appearances
     */
//    @MethodInfo(hide=true)
    public void setAppearances(AppearanceArray array) {
        appearances = array;
    }

    /**
     * Generates from the latest existing plot file a shape which is shown.
     * This shape represents the temporary calculated result
     * 
     * @return the generated Shape3DArray
     */
    @MethodInfo(valueName = " ", valueOptions = "doEmpty=false; hideConnector=true", interactive=false)
    public Shape3DArray getShape() {

        TxT2Geometry loader = new TxT2Geometry();
        Geometry g = null;

        if (appearances == null) {
            appearances = new CustomAppearance().getAppearances(
                    null, null, null);
        }

        Shape3DArray shapes = null;

        try {
            shapes = new Shape3DArray();
            g = loader.loadTxt(new File(checkForNextFile()));

            if (g != null) {
                for (Appearance a : appearances) {
                    shapes.add(new Shape3D(g, a));
                }
            }
        } catch (Exception ex) {
            //
            shapes = null;
        }

        return shapes;
    }

    /**
     * Methode that invoke for the user again and again getShape() to get the latest
     * result of the calculation.
     */
    @MethodInfo(callOptions="autoinvoke", interactive = false, hide=true)
    public void run() {

//        int id = mainCanvas.getInspector().
//                getCanvasWindowID(LivePlotter.this);
        
        int id = mainCanvas.getInspector().getObjectID(LivePlotter.this);
                
        
        
        VisualObject vObj =
                (VisualObject) mainCanvas.getWindows().getById(id);

        vObj.getRemoveTasks().add(new Task() {

            @Override
            public void run() {
                if (runningAnimation!= null){
                    runningAnimation.requestDeletion();
                }
            }
        });

        DefaultObjectRepresentation oRep =
                vObj.getObjectRepresentation();
        thisMethod = null;

        for (DefaultMethodRepresentation mRep : oRep.getMethods()) {
            if (mRep.getName().equals("getShape()")) {
                thisMethod = mRep;
                break;
            }
        }
        final LivePlotAnimation a = new LivePlotAnimation();

        a.addFrameListener(new FrameListener() {

            @Override
            public void frameStarted(double time) {
                if (time == 1.0 ) {

                    if (thisMethod != null && !a.deletionRequested()) {
                        thisMethod.invokeAsCallParent(false);
                    }
                }
            }
        });

        a.setDuration(0.033);

        a.setDeleteAfterExecution(false);
        mainCanvas.getAnimationManager().addUniqueAnimation(a);

        if (runningAnimation != null) {
            stop();
        }
        runningAnimation = a;
    }

    private void stop() {
        if (runningAnimation != null) {
            runningAnimation.requestDeletion();
        }
    }
}
/**
 * Necessary to differ the used animation in run() from an normal animation
 * and make no influence on other animations in the VRL.
 *
 * @author Cupido
 */
class LivePlotAnimation extends Animation {
    //
}
